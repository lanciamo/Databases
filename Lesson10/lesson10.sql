/* 1. Самое больное место в наших запросах это вычисление user.id пользователя КОТОРОМУ поставили лайк. Второе по важности - вычисление "облака дружбы" вокруг пользователя. В остальных случаях взаимных вычислений не возникает таких многоходовых манипуляций. Да и участвуют в расчетах столбцы в статусе PRIMARY KEY, которые индексируются автоматически. Поэтому я  предлагаю ограничиться индексами likes.like_type + likes.item_id.
при составлении запросов учитывать порядок составного индекса в таблице likes/
*/
CREATE INDEX likes_types_plus_item_id_idx ON likes(like_type_id, item_id);


-- 2. -- Денормализация

-- Задание на денормализацию
-- Разобраться как построен и работает следующий запрос:

SELECT SUM(count) as overall FROM (
	SELECT 	
		CONCAT(u.firstname, ' ', u.lastname) as user, 
		count(l.id) as count, 
		TIMESTAMPDIFF(YEAR, p.birthday, NOW()) AS age
			FROM users AS u
		INNER JOIN profiles AS p
			ON p.user_id = u.id
		LEFT JOIN media as m
			ON m.user_id = u.id
		LEFT JOIN messages as t
			ON t.from_user_id = u.id
		LEFT JOIN
			likes AS l
				ON l.item_id = u.id AND l.like_type_id = 5
				OR l.item_id = m.id AND l.like_type_id IN (1, 2, 4)
				OR l.item_id = t.id AND l.like_type_id = 3
		GROUP BY u.id
		ORDER BY p.birthday DESC
	LIMIT 10) AS likes;

/* Опять такая же непонятность - на MYSQL 8 в убунту работает, на маке нет(
Сам запрос похож на правду. Исправил в соответсвии со своим обозначением like_type

в целом, вопрос на мой взгляд перекликается с первым заданием. Выяснение связей внутри
базы vk, гораздо важнее непосредственно контента. Именно на анализе связей работают
рекомендательные сервисы, главный двигатель всего. Самое больное место конкретно нашей базы - это необходимость вечно вычислять КОМУ поставили лайк. Поэтому я бы просто добавил такой столбец в likes. А тригерами обложил возможные несоответсвия при проставлении лайка. 

Соответсвенно это запрос упростился бы заметно - убрали бы два JOIN. Конечно, Нормальной форме
база перестанет соответствовать, но оно того стоит.